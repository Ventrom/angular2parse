{"version":3,"file":"angular2parse.mjs","sources":["../../../projects/angular2parse/src/lib/angular/facade/lang.ts","../../../projects/angular2parse/src/lib/angular/compiler/assertions.ts","../../../projects/angular2parse/src/lib/angular/compiler/ast.ts","../../../projects/angular2parse/src/lib/angular/compiler/chars.ts","../../../projects/angular2parse/src/lib/angular/compiler/interpolation-config.ts","../../../projects/angular2parse/src/lib/angular/compiler/lexer.ts","../../../projects/angular2parse/src/lib/angular/compiler/parser.ts","../../../projects/angular2parse/src/lib/util/binary-operations.ts","../../../projects/angular2parse/src/lib/util/lang.ts","../../../projects/angular2parse/src/lib/visitors/parse-visitor-compiler.ts","../../../projects/angular2parse/src/lib/visitors/parse-visitor-resolver.ts","../../../projects/angular2parse/src/lib/parse.ts","../../../projects/angular2parse/src/lib/module.ts","../../../projects/angular2parse/src/public-api.ts","../../../projects/angular2parse/src/angular2parse.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface BrowserNodeGlobal {\n    Object: typeof Object;\n    Array: typeof Array;\n    Map: typeof Map;\n    Set: typeof Set;\n    Date: DateConstructor;\n    RegExp: RegExpConstructor;\n    JSON: typeof JSON;\n    Math: any;  // typeof Math;\n    assert(condition: any): void;\n    Reflect: any;\n    getAngularTestability: Function;\n    getAllAngularTestabilities: Function;\n    getAllAngularRootElements: Function;\n    frameworkStabilizers: Array<Function>;\n    setTimeout: Function;\n    clearTimeout: Function;\n    setInterval: Function;\n    clearInterval: Function;\n    encodeURI: Function;\n}\n\n\nexport function getTypeNameForDebugging(type: any): string {\n    return type['name'] || typeof type;\n}\n\nexport function isPresent(obj: any): boolean {\n    return obj != null;\n}\n\nexport function isBlank(obj: any): boolean {\n    return obj == null;\n}\n\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\nexport function isStrictStringMap(obj: any): boolean {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nexport function stringify(token: any): string {\n    if (typeof token === 'string') {\n        return token;\n    }\n\n    if (token == null) {\n        return '' + token;\n    }\n\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n\n    if (token.name) {\n        return `${token.name}`;\n    }\n\n    const res = token.toString();\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class NumberWrapper {\n    static parseIntAutoRadix(text: string): number {\n        const result: number = parseInt(text);\n        if (isNaN(result)) {\n            throw new Error('Invalid integer literal when parsing ' + text);\n        }\n        return result;\n    }\n\n    static isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n\n// JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n    return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n}\n\nexport function isJsObject(o: any): boolean {\n    return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n\nexport function print(obj: Error | Object) {\n    // tslint:disable-next-line:no-console\n    console.log(obj);\n}\n\nexport function warn(obj: Error | Object) {\n    console.warn(obj);\n}\n\nexport function setValueOnPath(global: any, path: string, value: any) {\n    const parts = path.split('.');\n    let obj: any = global;\n    while (parts.length > 1) {\n        const name = parts.shift();\n        if (obj.hasOwnProperty(name) && obj[name] != null) {\n            obj = obj[name];\n        } else {\n            obj = obj[name] = {};\n        }\n    }\n    if (obj === undefined || obj === null) {\n        obj = {};\n    }\n    obj[parts.shift()] = value;\n}\n\nexport function isPrimitive(obj: any): boolean {\n    return !isJsObject(obj);\n}\n\nexport function escapeRegExp(s: string): string {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank, isPresent} from '../facade/lang';\n\nconst isDevMode = () => false;\n\nexport function assertArrayOfStrings(identifier: string, value: any) {\n    if (!isDevMode() || isBlank(value)) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\n    }\n    for (let i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\n        }\n    }\n}\n\nconst INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,        // empty\n    /[<>]/,         // html tag\n    /^[{}]$/,       // i18n expansion\n    /&(#|[a-z])/i,  // character reference,\n    /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n    if (isPresent(value) && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    } else if (isDevMode() && !isBlank(value)) {\n        const start = value[0] as string;\n        const end = value[1] as string;\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {isBlank} from '../facade/lang';\n\nexport class ParserError {\n    public message: string;\n    constructor(\n        message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\n\nexport class ParseSpan {\n    constructor(public start: number, public end: number) {}\n}\n\nexport class AST {\n    constructor(public span: ParseSpan) {}\n    visit(visitor: AstVisitor, context: any = null): any { return null; }\n    toString(): string { return 'AST'; }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n    constructor(\n        span: ParseSpan, public prefix: string, public uninterpretedExpression: string,\n        public location: any) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitQuote(this, context); }\n    toString(): string { return 'Quote'; }\n}\n\nexport class EmptyExpr extends AST {\n    visit(visitor: AstVisitor, context: any = null) {\n        // do nothing\n    }\n}\n\nexport class ImplicitReceiver extends AST {\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitChain(this, context); }\n}\n\nexport class Conditional extends AST {\n    constructor(span: ParseSpan, public condition: AST, public trueExp: AST, public falseExp: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitConditional(this, context);\n    }\n}\n\nexport class PropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\n\nexport class PropertyWrite extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public value: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\n\nexport class SafePropertyRead extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\n\nexport class KeyedRead extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\n\nexport class KeyedWrite extends AST {\n    constructor(span: ParseSpan, public obj: AST, public key: AST, public value: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\n\nexport class BindingPipe extends AST {\n    constructor(span: ParseSpan, public exp: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return visitor.visitPipe(this, context); }\n}\n\nexport class LiteralPrimitive extends AST {\n    constructor(span: ParseSpan, public value: any) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\n\nexport class LiteralArray extends AST {\n    constructor(span: ParseSpan, public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\n\nexport class LiteralMap extends AST {\n    constructor(span: ParseSpan, public keys: any[], public values: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\n\nexport class Interpolation extends AST {\n    constructor(span: ParseSpan, public strings: any[], public expressions: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitInterpolation(this, context);\n    }\n}\n\nexport class Binary extends AST {\n    constructor(span: ParseSpan, public operation: string, public left: AST, public right: AST) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitBinary(this, context);\n    }\n}\n\nexport class PrefixNot extends AST {\n    constructor(span: ParseSpan, public expression: AST) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\n\nexport class MethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitMethodCall(this, context);\n    }\n}\n\nexport class SafeMethodCall extends AST {\n    constructor(span: ParseSpan, public receiver: AST, public name: string, public args: any[]) {\n        super(span);\n    }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitSafeMethodCall(this, context);\n    }\n}\n\nexport class FunctionCall extends AST {\n    constructor(span: ParseSpan, public target: AST, public args: any[]) { super(span); }\n    visit(visitor: AstVisitor, context: any = null): any {\n        return visitor.visitFunctionCall(this, context);\n    }\n}\n\nexport class ASTWithSource extends AST {\n    constructor(\n        public ast: AST, public source: string, public location: string,\n        public errors: ParserError[]) {\n        super(new ParseSpan(0, isBlank(source) ? 0 : source.length));\n    }\n    visit(visitor: AstVisitor, context: any = null): any { return this.ast.visit(visitor, context); }\n    toString(): string { return `${this.source} in ${this.location}`; }\n}\n\nexport class TemplateBinding {\n    constructor(\n        public span: ParseSpan, public key: string, public keyIsVar: boolean, public name: string,\n        public expression: ASTWithSource) {}\n}\n\nexport interface AstVisitor {\n    visitBinary(ast: Binary, context: any): any;\n    visitChain(ast: Chain, context: any): any;\n    visitConditional(ast: Conditional, context: any): any;\n    visitFunctionCall(ast: FunctionCall, context: any): any;\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n    visitInterpolation(ast: Interpolation, context: any): any;\n    visitKeyedRead(ast: KeyedRead, context: any): any;\n    visitKeyedWrite(ast: KeyedWrite, context: any): any;\n    visitLiteralArray(ast: LiteralArray, context: any): any;\n    visitLiteralMap(ast: LiteralMap, context: any): any;\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n    visitMethodCall(ast: MethodCall, context: any): any;\n    visitPipe(ast: BindingPipe, context: any): any;\n    visitPrefixNot(ast: PrefixNot, context: any): any;\n    visitPropertyRead(ast: PropertyRead, context: any): any;\n    visitPropertyWrite(ast: PropertyWrite, context: any): any;\n    visitQuote(ast: Quote, context: any): any;\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n    visitBinary(ast: Binary, context: any): any {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    }\n    visitChain(ast: Chain, context: any): any { return this.visitAll(ast.expressions, context); }\n    visitConditional(ast: Conditional, context: any): any {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    }\n    visitPipe(ast: BindingPipe, context: any): any {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any { return null; }\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    }\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast: LiteralMap, context: any): any { return this.visitAll(ast.values, context); }\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any { return null; }\n    visitMethodCall(ast: MethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        ast.expression.visit(this);\n        return null;\n    }\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    }\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        ast.receiver.visit(this);\n        return null;\n    }\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    }\n    visitAll(asts: AST[], context: any): any {\n        asts.forEach(ast => ast.visit(this, context));\n        return null;\n    }\n    visitQuote(ast: Quote, context: any): any { return null; }\n}\n\nexport class AstTransformer implements AstVisitor {\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\n\n    visitInterpolation(ast: Interpolation, context: any): AST {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n        return new LiteralPrimitive(ast.span, ast.value);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): AST {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value);\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): AST {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n        return new SafeMethodCall(\n            ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitFunctionCall(ast: FunctionCall, context: any): AST {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): AST {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): AST {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    }\n\n    visitBinary(ast: Binary, context: any): AST {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): AST {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    }\n\n    visitConditional(ast: Conditional, context: any): AST {\n        return new Conditional(\n            ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n\n    visitPipe(ast: BindingPipe, context: any): AST {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): AST {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n        return new KeyedWrite(\n            ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n\n    visitAll(asts: any[]): any[] {\n        const res = new Array(asts.length);\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n\n    visitChain(ast: Chain, context: any): AST {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    }\n\n    visitQuote(ast: Quote, context: any): AST {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n    return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from './assertions';\n\nexport class InterpolationConfig {\n    static fromArray(markers: [string, string]): InterpolationConfig {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n\n    constructor(public start: string, public end: string){};\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {NumberWrapper} from '../facade/lang';\n\nexport enum TokenType {\n    Character,\n    Identifier,\n    Keyword,\n    String,\n    Operator,\n    Number,\n    Error\n}\n\nconst KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n    tokenize(text: string): Token[] {\n        const scanner = new _Scanner(text);\n        const tokens: Token[] = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\n\nexport class Token {\n    constructor(\n        public index: number, public type: TokenType, public numValue: number,\n        public strValue: string) {}\n\n    isCharacter(code: number): boolean {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n\n    isNumber(): boolean { return this.type == TokenType.Number; }\n\n    isString(): boolean { return this.type == TokenType.String; }\n\n    isOperator(operater: string): boolean {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    }\n\n    isIdentifier(): boolean { return this.type == TokenType.Identifier; }\n\n    isKeyword(): boolean { return this.type == TokenType.Keyword; }\n\n    isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n\n    isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n\n    isKeywordUndefined(): boolean {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n\n    isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n\n    isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n\n    isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n\n    isError(): boolean { return this.type == TokenType.Error; }\n\n    toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n\n    toString(): string {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n    return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n    return new Token(index, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n    return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\n\nclass _Scanner {\n    length: number;\n    peek: number = 0;\n    index: number = -1;\n\n    constructor(public input: string) {\n        this.length = input.length;\n        this.advance();\n    }\n\n    advance() {\n        this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n    }\n\n    scanToken(): Token {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n\n        // Skip whitespace.\n        while (peek <= chars.$SPACE) {\n            if (++index >= length) {\n                peek = chars.$EOF;\n                break;\n            } else {\n                peek = input.charCodeAt(index);\n            }\n        }\n\n        this.peek = peek;\n        this.index = index;\n\n        if (index >= length) {\n            return null;\n        }\n\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek)) return this.scanIdentifier();\n        if (chars.isDigit(peek)) return this.scanNumber(index);\n\n        const start: number = index;\n        switch (peek) {\n            case chars.$PERIOD:\n                this.advance();\n                return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, chars.$PERIOD);\n            case chars.$LPAREN:\n            case chars.$RPAREN:\n            case chars.$LBRACE:\n            case chars.$RBRACE:\n            case chars.$LBRACKET:\n            case chars.$RBRACKET:\n            case chars.$COMMA:\n            case chars.$COLON:\n            case chars.$SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case chars.$SQ:\n            case chars.$DQ:\n                return this.scanString();\n            case chars.$HASH:\n            case chars.$PLUS:\n            case chars.$MINUS:\n            case chars.$STAR:\n            case chars.$SLASH:\n            case chars.$PERCENT:\n            case chars.$CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case chars.$QUESTION:\n                return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n            case chars.$LT:\n            case chars.$GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n            case chars.$BANG:\n            case chars.$EQ:\n                return this.scanComplexOperator(\n                    start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n            case chars.$AMPERSAND:\n                return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n            case chars.$BAR:\n                return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n            case chars.$NBSP:\n                while (chars.isWhitespace(this.peek)) this.advance();\n                return this.scanToken();\n        }\n\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n\n    scanCharacter(start: number, code: number): Token {\n        this.advance();\n        return newCharacterToken(start, code);\n    }\n\n\n    scanOperator(start: number, str: string): Token {\n        this.advance();\n        return newOperatorToken(start, str);\n    }\n\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     * @returns {Token}\n     */\n    scanComplexOperator(\n        start: number, one: string, twoCode: number, two: string, threeCode?: number,\n        three?: string): Token {\n        this.advance();\n        let str: string = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    }\n\n    scanIdentifier(): Token {\n        const start: number = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek)) this.advance();\n        const str: string = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    }\n\n    scanNumber(start: number): Token {\n        let simple: boolean = (this.index === start);\n        this.advance();  // Skip initial digit.\n        while (true) {\n            if (chars.isDigit(this.peek)) {\n                // Do nothing.\n            } else if (this.peek == chars.$PERIOD) {\n                simple = false;\n            } else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek)) this.advance();\n                if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n                simple = false;\n            } else {\n                break;\n            }\n            this.advance();\n        }\n        const str: string = this.input.substring(start, this.index);\n        const value: number = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    }\n\n    scanString(): Token {\n        const start: number = this.index;\n        const quote: number = this.peek;\n        this.advance();  // Skip initial quote.\n\n        let buffer: string = '';\n        let marker: number = this.index;\n        const input: string = this.input;\n\n        while (this.peek != quote) {\n            if (this.peek == chars.$BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let unescapedCode: number;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == chars.$u) {\n                    // 4 character hex code for unicode character.\n                    const hex: string = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    } else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i: number = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                } else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            } else if (this.peek == chars.$EOF) {\n                return this.error('Unterminated quote', 0);\n            } else {\n                this.advance();\n            }\n        }\n\n        const last: string = input.substring(marker, this.index);\n        this.advance();  // Skip terminating quote.\n\n        return newStringToken(start, buffer + last);\n    }\n\n    error(message: string, offset: number): Token {\n        const position: number = this.index + offset;\n        return newErrorToken(\n            position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n    return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n        (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n    if (input.length == 0) return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek)) return false;\n    scanner.advance();\n    while (scanner.peek !== chars.$EOF) {\n        if (!isIdentifierPart(scanner.peek)) return false;\n        scanner.advance();\n    }\n    return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n        (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n    return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n    return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n    switch (code) {\n        case chars.$n:\n            return chars.$LF;\n        case chars.$f:\n            return chars.$FF;\n        case chars.$r:\n            return chars.$CR;\n        case chars.$t:\n            return chars.$TAB;\n        case chars.$v:\n            return chars.$VTAB;\n        default:\n            return code;\n    }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from './chars';\nimport {escapeRegExp, isBlank, isPresent} from '../facade/lang';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation-config';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\n\nexport class SplitInterpolation {\n    constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n    constructor(\n        public templateBindings: TemplateBinding[], public warnings: string[],\n        public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n    const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\n\nexport class Parser {\n    private errors: ParserError[] = [];\n\n    constructor(private _lexer: Lexer) {}\n\n    parseAction(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(this._stripComments(input));\n        const ast = new _ParseAST(\n            input, location, tokens, sourceToLex.length, true, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseBinding(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    parseSimpleBinding(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const ast = this._parseBindingAst(input, location, interpolationConfig);\n        const errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\n                `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    }\n\n    private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n\n    private _parseBindingAst(\n        input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        const quote = this._parseQuote(input, location);\n\n        if (isPresent(quote)) {\n            return quote;\n        }\n\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(\n            input, location, tokens, sourceToLex.length, false, this.errors,\n            input.length - sourceToLex.length)\n            .parseChain();\n    }\n\n    private _parseQuote(input: string, location: any): AST {\n        if (isBlank(input)) return null;\n        const prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1) return null;\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix)) return null;\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    }\n\n    parseTemplateBindings(prefixToken: string, input: string, location: any):\n    TemplateBindingParseResult {\n        const tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            const prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift(...prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    }\n\n    parseInterpolation(\n        input: string, location: any,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n        const split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null) return null;\n\n        const expressions: AST[] = [];\n\n        for (let i = 0; i < split.expressions.length; ++i) {\n            const expressionText = split.expressions[i];\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            const ast = new _ParseAST(\n                input, location, tokens, sourceToLex.length, false, this.errors,\n                split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n\n        return new ASTWithSource(\n            new Interpolation(\n                new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions),\n            input, location, this.errors);\n    }\n\n    splitInterpolation(\n        input: string, location: string,\n        interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        const strings: string[] = [];\n        const expressions: string[] = [];\n        const offsets: number[] = [];\n        let offset = 0;\n        for (let i = 0; i < parts.length; i++) {\n            const part: string = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            } else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            } else {\n                this._reportError(\n                    'Blank expressions are not allowed in interpolated strings', input,\n                    `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n                    location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n\n    wrapLiteralPrimitive(input: string, location: any): ASTWithSource {\n        return new ASTWithSource(\n            new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input,\n            location, this.errors);\n    }\n\n    private _stripComments(input: string): string {\n        const i = this._commentStart(input);\n        return isPresent(i) ? input.substring(0, i).trim() : input;\n    }\n\n    private _commentStart(input: string): number {\n        let outerQuote: number = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n\n            if (char === chars.$SLASH && nextChar == chars.$SLASH && isBlank(outerQuote)) return i;\n\n            if (outerQuote === char) {\n                outerQuote = null;\n            } else if (isBlank(outerQuote) && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n\n    private _checkNoInterpolation(\n        input: string, location: any, interpolationConfig: InterpolationConfig): void {\n        const regexp = _createInterpolateRegExp(interpolationConfig);\n        const parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\n                `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n                input,\n                `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n                location);\n        }\n    }\n\n    private _findInterpolationErrorColumn(\n        parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n        let errLocation = '';\n        for (let j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n        }\n\n        return errLocation.length;\n    }\n}\n\nexport class _ParseAST {\n    private rparensExpected = 0;\n    private rbracketsExpected = 0;\n    private rbracesExpected = 0;\n\n    index: number = 0;\n\n    constructor(\n        public input: string, public location: any, public tokens: Token[],\n        public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n        private offset: number) {}\n\n    peek(offset: number): Token {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n\n    get next(): Token { return this.peek(0); }\n\n    get inputIndex(): number {\n        return (this.index < this.tokens.length) ? this.next.index + this.offset :\n            this.inputLength + this.offset;\n    }\n\n    span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n    advance() { this.index++; }\n\n    optionalCharacter(code: number): boolean {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n\n    expectCharacter(code: number) {\n        if (this.optionalCharacter(code)) return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n\n    optionalOperator(op: string): boolean {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    expectOperator(operator: string) {\n        if (this.optionalOperator(operator)) return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n\n    expectIdentifierOrKeyword(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(`Unexpected token ${n}, expected identifier or keyword`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    expectIdentifierOrKeywordOrString(): string {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n\n    parseChain(): AST {\n        const exprs: AST[] = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n\n            if (this.optionalCharacter(chars.$SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter(chars.$SEMICOLON)) {\n                }  // read all semicolons\n            } else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0) return new EmptyExpr(this.span(start));\n        if (exprs.length == 1) return exprs[0];\n        return new Chain(this.span(start), exprs);\n    }\n\n    parsePipe(): AST {\n        let result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n\n            do {\n                const name = this.expectIdentifierOrKeyword();\n                const args: AST[] = [];\n                while (this.optionalCharacter(chars.$COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n\n        return result;\n    }\n\n    parseExpression(): AST { return this.parseConditional(); }\n\n    parseConditional(): AST {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n\n        if (this.optionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no: AST;\n            if (!this.optionalCharacter(chars.$COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start));\n            } else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        } else {\n            return result;\n        }\n    }\n\n    parseLogicalOr(): AST {\n        // '||'\n        let result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    }\n\n    parseLogicalAnd(): AST {\n        // '&&'\n        let result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    }\n\n    parseEquality(): AST {\n        // '==','!=','===','!=='\n        let result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseRelational(): AST {\n        // '<', '>', '<=', '>='\n        let result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseAdditive(): AST {\n        // '+', '-'\n        let result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parseMultiplicative(): AST {\n        // '*', '%', '/'\n        let result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n\n    parsePrefix(): AST {\n        if (this.next.type == TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result: AST;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(\n                        this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n                        result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n\n    parseCallChain(): AST {\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter(chars.$PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n\n            } else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n\n            } else if (this.optionalCharacter(chars.$LBRACKET)) {\n                this.rbracketsExpected++;\n                const key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter(chars.$RBRACKET);\n                if (this.optionalOperator('=')) {\n                    const value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                } else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n\n            } else if (this.optionalCharacter(chars.$LPAREN)) {\n                this.rparensExpected++;\n                const args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter(chars.$RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n\n            } else {\n                return result;\n            }\n        }\n    }\n\n    parsePrimary(): AST {\n        const start = this.inputIndex;\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter(chars.$RPAREN);\n            return result;\n\n        } else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n\n        } else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n\n        } else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n\n        } else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n\n        } else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n\n        } else if (this.optionalCharacter(chars.$LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList(chars.$RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter(chars.$RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n\n        } else if (this.next.isCharacter(chars.$LBRACE)) {\n            return this.parseLiteralMap();\n\n        } else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n        } else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n\n        } else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n\n        } else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start));\n        } else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start));\n        }\n    }\n\n    parseExpressionList(terminator: number): AST[] {\n        const result: AST[] = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n        }\n        return result;\n    }\n\n    parseLiteralMap(): LiteralMap {\n        const keys: string[] = [];\n        const values: AST[] = [];\n        const start = this.inputIndex;\n        this.expectCharacter(chars.$LBRACE);\n        if (!this.optionalCharacter(chars.$RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push(key);\n                this.expectCharacter(chars.$COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter(chars.$COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter(chars.$RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    }\n\n    parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n        const start = receiver.span.start;\n        const id = this.expectIdentifierOrKeyword();\n\n        if (this.optionalCharacter(chars.$LPAREN)) {\n            this.rparensExpected++;\n            const args = this.parseCallArguments();\n            this.expectCharacter(chars.$RPAREN);\n            this.rparensExpected--;\n            const span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n\n        } else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                } else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            } else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n\n                    const value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                } else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    }\n\n    parseCallArguments(): BindingPipe[] {\n        if (this.next.isCharacter(chars.$RPAREN)) return [];\n        const positionals: AST[] = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter(chars.$COMMA));\n        return positionals as BindingPipe[];\n    }\n\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     */\n    expectTemplateBindingKey(): string {\n        let result = '';\n        let operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n\n        return result.toString();\n    }\n\n    parseTemplateBindings(): TemplateBindingParseResult {\n        const bindings: TemplateBinding[] = [];\n        let prefix: string = null;\n        const warnings: string[] = [];\n        while (this.index < this.tokens.length) {\n            const start = this.inputIndex;\n            const keyIsVar: boolean = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            let key = this.expectTemplateBindingKey();\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                } else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter(chars.$COLON);\n            let name: string = null;\n            let expression: ASTWithSource = null;\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                } else {\n                    name = '\\$implicit';\n                }\n            } else if (this.next !== EOF && !this.peekKeywordLet()) {\n                const start = this.inputIndex;\n                const ast = this.parsePipe();\n                const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (!this.optionalCharacter(chars.$SEMICOLON)) {\n                this.optionalCharacter(chars.$COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    }\n\n    error(message: string, index: number = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n\n    private locationText(index: number = null) {\n        if (isBlank(index)) index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n\n    // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n    private skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n        (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n        (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n        (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(\n                    new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n    static check(ast: AST): string[] {\n        const s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    }\n\n    errors: string[] = [];\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n    visitInterpolation(ast: Interpolation, context: any) {}\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n    visitPropertyRead(ast: PropertyRead, context: any) {}\n\n    visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n    visitMethodCall(ast: MethodCall, context: any) {}\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n    visitFunctionCall(ast: FunctionCall, context: any) {}\n\n    visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n    visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n    visitBinary(ast: Binary, context: any) {}\n\n    visitPrefixNot(ast: PrefixNot, context: any) {}\n\n    visitConditional(ast: Conditional, context: any) {}\n\n    visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n\n    visitKeyedRead(ast: KeyedRead, context: any) {}\n\n    visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n    visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n    visitChain(ast: Chain, context: any) {}\n\n    visitQuote(ast: Quote, context: any) {}\n}","export const BinaryOperations = new Map<string, any>([\n    ['==', (left: any, right: any) => left == right],\n    ['===', (left: any, right: any) => left === right],\n    ['!=', (left: any, right: any) => left != right],\n    ['!==', (left: any, right: any) => left !== right],\n    ['&&', (left: any, right: any) => left && right],\n    ['||', (left: any, right: any) => left || right],\n    ['+', (left: any, right: any) => left + right],\n    ['-', (left: any, right: any) => left - right],\n    ['/', (left: any, right: any) => left / right],\n    ['*', (left: any, right: any) => left * right],\n    ['%', (left: any, right: any) => left % right],\n    ['<', (left: any, right: any) => left < right],\n    ['<=', (left: any, right: any) => left <= right],\n    ['>', (left: any, right: any) => left > right],\n    ['>=', (left: any, right: any) => left >= right],\n]);","export function compileToJSON(json: any) {\n    return JSON.stringify(json).replace(/\"/g, '');\n}\n\nexport function isPresent(obj: any) {\n    return obj !== null && obj !== undefined;\n}\n\nexport function isJsObject(obj: any) {\n    return obj !== null && (typeof obj === 'function' || typeof obj === 'object');\n}\n\nexport function isFunction(val: any) {\n    return typeof val === 'function';\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport { compileToJSON } from '../util';\n\nexport class ParseVisitorCompiler extends RecursiveAstVisitor {\n\n    visitBinary(ast: Binary): any {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n\n        return `${left} ${ast.operation} ${right}`;\n    }\n\n    // TODO\n    visitChain(ast: Chain): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitConditional(ast: Conditional): any {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n\n        return `${condition} ? ${trueExp} : ${falseExp}`;\n    }\n\n    visitPipe(ast: BindingPipe): any {\n        const pipe = ast.name;\n        const args = this.visitAll(ast.args);\n        const value = ast.exp.visit(this);\n        args.unshift(value);\n\n        return `pipesCache.get('${pipe}').transform.apply(null, ${compileToJSON(args)})`;\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall): any {\n        const target = ast.target.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${target}.apply(${target}, ${args})`;\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver): any {\n        return `context`;\n    }\n\n    visitInterpolation(ast: Interpolation): any {\n        return this.visitAll(ast.expressions)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead): any {\n        const obj = ast.obj.visit(this);\n        const key = ast.key.visit(this);\n\n        return `${obj}[${key}]`;\n    }\n\n    visitKeyedWrite(ast: KeyedWrite): any {\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray): any {\n        return compileToJSON(this.visitAll(ast.expressions));\n    }\n\n    visitLiteralMap(ast: LiteralMap): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return compileToJSON(result);\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive): any {\n        return typeof ast.value === 'string' ? `'${ast.value}'` : ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitPrefixNot(ast: PrefixNot): any {\n        return ast.expression.visit(this);\n    }\n\n    visitPropertyRead(ast: PropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitPropertyWrite(ast: PropertyWrite): any {\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead): any {\n        const property = ast.name;\n        const receiver = ast.receiver.visit(this);\n\n        return `${receiver}['${property}']`;\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall): any {\n        const methodName = ast.name;\n        const receiver = ast.receiver.visit(this);\n        const args = compileToJSON(this.visitAll(ast.args));\n\n        return `${receiver}['${methodName}'].apply(${receiver}, ${args})`;\n    }\n\n    visitAll(asts: AST[]): any {\n        return asts.map(ast => ast.visit(this));\n    }\n\n    visitQuote(ast: Quote): any {\n        return null;\n    }\n}","import {\n    AST,\n    RecursiveAstVisitor,\n    PropertyRead,\n    MethodCall,\n    KeyedRead,\n    ImplicitReceiver,\n    LiteralPrimitive,\n    Binary,\n    Chain,\n    Conditional,\n    BindingPipe,\n    FunctionCall,\n    Interpolation,\n    KeyedWrite,\n    LiteralArray,\n    LiteralMap,\n    PrefixNot,\n    PropertyWrite,\n    SafePropertyRead,\n    SafeMethodCall,\n    Quote\n} from '../angular';\nimport * as util from '../util';\nimport { BinaryOperations } from '../util/binary-operations';\n\nexport class ParseVisitorResolver extends RecursiveAstVisitor {\n\n    constructor(private pipes: Map<string, any>) {\n        super();\n    };\n\n    visitBinary(ast: Binary, context: any): any {\n        const execFn = BinaryOperations.get(ast.operation);\n\n        if (!execFn) {\n            throw new Error(`Parse ERROR: on visitBinary, unknown operator ${ast.operation}`);\n        }\n\n        return execFn(ast.left.visit(this, context), ast.right.visit(this, context));\n    }\n\n    // TODO\n    visitChain(ast: Chain, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitConditional(ast: Conditional, context: any): any {\n        if (ast.condition.visit(this, context)) {\n            return ast.trueExp.visit(this, context);\n        }\n        else if (util.isPresent(ast.falseExp)) {\n            return ast.falseExp.visit(this, context);\n        }\n\n        return null;\n    }\n\n    visitPipe(ast: BindingPipe, context: any): any {\n        const pipe = this.pipes.get(ast.name);\n\n        if (!pipe) {\n            throw new Error(`pipe ${ast.name} not found.`);\n        }\n\n        if (!pipe.transform) {\n            throw new Error(`Parse ERROR: on visitPipe, transform method doesn't exist on pipe ${ast.name}.`);\n        }\n\n        const value = ast.exp.visit(this, context);\n        const pipeArgs = this.visitAll(ast.args, context);\n\n        pipeArgs.unshift(value);\n\n        return pipe.transform.apply(null, pipeArgs);\n    }\n\n    // TODO\n    visitFunctionCall(ast: FunctionCall, context: any): any {\n        const target = ast.target.visit(this, context);\n\n        if (!util.isFunction(target)) {\n            throw new Error(`Parse ERROR: on visitFunctionCall, target is not a function.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return target.apply(target, args);\n    }\n\n    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n        return context;\n    }\n\n    visitInterpolation(ast: Interpolation, context: any): any {\n        return this.visitAll(ast.expressions, context)[0];\n    }\n\n    visitKeyedRead(ast: KeyedRead, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        return obj[key];\n    }\n\n    visitKeyedWrite(ast: KeyedWrite, context: any): any {\n        const obj = ast.obj.visit(this, context);\n        const key = ast.key.visit(this, context);\n        const value = ast.value.visit(this, context);\n        obj[key] = value;\n        return null;\n    }\n\n    visitLiteralArray(ast: LiteralArray, context: any): any {\n        return this.visitAll(ast.expressions, context);\n    }\n\n    visitLiteralMap(ast: LiteralMap, context: any): any {\n        const result = {};\n        const keys = ast.keys;\n        const values = this.visitAll(ast.values, context);\n\n        for (let i = 0, length = keys.length; i < length; i++) {\n            result[keys[i]] = values[i];\n        }\n\n        return result;\n    }\n\n    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {\n        return ast.value;\n    }\n\n    visitMethodCall(ast: MethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitPrefixNot(ast: PrefixNot, context: any): any {\n        return ast.expression.visit(this, context);\n    }\n\n    visitPropertyRead(ast: PropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitPropertyWrite(ast: PropertyWrite, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitPropertyRead, invalid property receiver.`);\n        }\n\n        receiver[ast.name] = ast.value.visit(this, context);\n        return null;\n    }\n\n    visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafePropertyRead, invalid property receiver.`);\n        }\n\n        return receiver[ast.name];\n    }\n\n    visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n        const receiver = ast.receiver.visit(this, context);\n\n        if (!util.isJsObject(receiver)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, invalid method receiver.`);\n        }\n\n        const method = receiver[ast.name];\n\n        if (!util.isFunction(method)) {\n            throw new Error(`Parse ERROR: on visitSafeMethodCall, method ${ast.name} doesn't exist on receiver.`);\n        }\n\n        const args = this.visitAll(ast.args, context);\n        return method.apply(receiver, args);\n    }\n\n    visitAll(asts: AST[], context: any): any {\n        return asts.map(ast => ast.visit(this, context));\n    }\n\n    visitQuote(ast: Quote, context: any): any {\n        throw new Error(`Parse ERROR: on visitQuote, quote expression not allowed.`);\n    }\n}","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport { Parser, Lexer, ASTWithSource } from './angular';\nimport { ParseVisitorResolver, ParseVisitorCompiler } from './visitors';\n\nexport const PIPES_CONFIG = new InjectionToken('PipesConfig');\n\nexport interface PipesConfig {\n  pipeName: string;\n  pipeInstance: any;\n}\n\n@Injectable({providedIn: 'root'})\nexport class Parse {\n  private _parser: Parser = new Parser(new Lexer());\n  private _pipesCache: Map<string, any> = new Map<string, any>();\n  private _evalCache: Map<string, Function> = new Map<string, Function>();\n  private _calcCache: Map<string, Function> = new Map<string, Function>();\n\n  /**\n   * Used to dependency inject the Angular 2 parser.\n   */\n\n  constructor(@Optional() @Inject(PIPES_CONFIG) pipesConfigs: PipesConfig[][]) {\n    if (pipesConfigs && pipesConfigs.length) {\n      pipesConfigs\n        .filter(pipes => pipes && pipes.length)\n        .forEach(pipes => pipes.forEach((pipeData) => this._pipesCache.set(pipeData.pipeName, pipeData.pipeInstance)));\n    }\n  }\n\n  eval(expression: string): Function {\n    if (this._evalCache.has(expression)) {\n      return this._evalCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorCompiler();\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const fnBody = ast.visit(visitor);\n    const pipesCache = this._pipesCache;\n    const getFn = new Function('context', 'pipesCache', `return ${fnBody};`);\n\n    const evalParse = function evalParse(context: any): any {\n      return getFn(context, pipesCache);\n    };\n\n    this._evalCache.set(expression, evalParse);\n\n    return evalParse;\n  }\n\n  calc(expression: string): Function {\n    if (this._calcCache.has(expression)) {\n      return this._calcCache.get(expression);\n    }\n\n    const visitor = new ParseVisitorResolver(this._pipesCache);\n\n    let ast: ASTWithSource = this._parser.parseInterpolation(expression, 'Parse');\n\n    if (!ast) {\n      ast = this._parser.parseBinding(expression, 'Parse');\n    }\n\n    const calcParse = function calcParse(context: any): any {\n      return ast.visit(visitor, context);\n    };\n\n    this._calcCache.set(expression, calcParse);\n\n    return calcParse;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { Parse, PIPES_CONFIG, PipesConfig } from './parse';\n\n@NgModule()\nexport class Angular2ParseModule {\n  static forRoot(pipesConfigMap: PipesConfig[]): ModuleWithProviders<any> {\n    return {\n      ngModule: Angular2ParseModule,\n      providers: [{provide: PIPES_CONFIG, multi: true, useValue: pipesConfigMap || []}]\n    };\n  }\n}\n","/*\n * Public API Surface of angular2parse\n */\nexport * from './lib/module';\nexport * from './lib/parse'\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["isPresent","isJsObject","chars.$EOF","chars.$SPACE","chars.isDigit","chars.$PERIOD","chars.$LPAREN","chars.$RPAREN","chars.$LBRACE","chars.$RBRACE","chars.$LBRACKET","chars.$RBRACKET","chars.$COMMA","chars.$COLON","chars.$SEMICOLON","chars.$SQ","chars.$DQ","chars.$HASH","chars.$PLUS","chars.$MINUS","chars.$STAR","chars.$SLASH","chars.$PERCENT","chars.$CARET","chars.$QUESTION","chars.$LT","chars.$GT","chars.$EQ","chars.$BANG","chars.$AMPERSAND","chars.$BAR","chars.$NBSP","chars.isWhitespace","chars.$BACKSLASH","chars.$u","chars.$a","chars.$z","chars.$A","chars.$Z","chars.$_","chars.$$","chars.isAsciiLetter","chars.$e","chars.$E","chars.$BT","chars.$n","chars.$LF","chars.$f","chars.$FF","chars.$r","chars.$CR","chars.$t","chars.$TAB","chars.$v","chars.$VTAB","util.isPresent","util.isFunction","util.isJsObject"],"mappings":"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"}